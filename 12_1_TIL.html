<!doctype html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <title>[20200309_TIL_12_1]</title>
        <style>
            .stress{
                color: red;
            }
        </style>
    </head>
    <body>
        <h1>12. 애플리케이션 사용자 공격</h1>
        <ul>
            <li>웹 애플리케이션에서 사용되는 공격 기법은 주로 서버 측 애플리케이션을 대상으로 한다.</li>
            <li>애플리케이션의 사용자를 공격하는 공격 기법과 관련된 취약점은 주로 서버 측 애플리케이션 내에 존재한다.</li>
            <li>공격자는 애플리케이션의 특정 부분에 악의적인 공격을 입력해 최종 사용자들이 비정상적인 행위를 하게 만들며, 그 결과 세션 하이재킹 , 비인가된 행위, 개인 데이터 노출 등의 취약점과 유사한 결과를 얻는다.</li>
            <li>공격자는 사용자의 컴푸터에 악의적인 명령을 실행하거나 키보드를 통해 눌려지는 키를 기록하는 등 예상하지 못한 작업을 수행한다.</li>
            <li>최근 몇년 간 보안 위협이 점차 서버에서 소프트웨어로 전향되고 있다.</li>
            <div>
                <h2>1. 크로스사이트 스크립팅</h2>
                <ul>
                    <li>크로스사이트 스크립팅은 다른 사용자를 공격하는 기법 중 최고의 기법이라고 할 수 있다. 가장 널리 알려진 웹 애플리케이션 취약점이며, 대부분의 애플리케이션을 위협하고 있는 취약점이기도 하다.</li>
                    <li>공격자는 공격을 극대화시키기 위해 다른 취약점과 결함해서 공격을 시도하는데 이 경우 스크립팅 공격은 바이러스나 스스로 진화하는 웜으로 변한다.</li>
                    <div>
                        <h3>1_1. 리플렉티드 크로스사이트 스크립팅</h3>
                        <ul>
                            <li>크로스사이트 스크립팅 취약점은 일반적으로 애플리케이션이 동적인 페이지를 사용해 사용자들에게 에러 메시지를 보여줄 떄 발생한다. 페이지는 매개변수로 문자를 받아 사용자에게 받은 메시지를 다시 보낸다.</li>
                            <li>에러 페이지 안에 하드 코딩된 개별적인 에러 메시지를 사용할 필요 없이 애플리케이션의 어느 곳에서든 일반적인 에러 메시지를 호출할 수 있기 떄문에 이런 유형의 매커니즘은 개발자들에게 매우 편리하게 사용된다.</li>
                            <li>사용자가 입력한 값을 중간에 가로채 이를 서버 응답의 HTML 소스에 삽입하는 작업은 크로스사이트 스크립팅 취약점을 이용한 공격 방법 중 하나이다. 이떄 입력값에 대한 필터링이 중간에 이루어지지 않았다면 해당 애플리케이션은 확실히 취약하다고 할 수 있다.</li>
                            <li>사용자가 크로스사이트 스크립트 코드가 포함된 자바스크립트를 요청할 떄 사용자에게 다시 되돌려지기 떄문에 반사된 크로스사이트 스크립트라고 불린다. 가씀 퍼스트 오더 크로스사이트 스크립팅이라고 불리기도 한다.</li>
                            <div>
                                <h4>1_1_1. 취약점 이용</h4>
                                <ul>
                                    <li>XSS를 이용앴을 때 일반적으로 볼 수 있는 가장 간단한 공격 중 하나는 인가된 사용자의 세션 토큰을 공격자가 가로챌 수 있다는 것이다.</li>
                                    <li>반사된 크로스 사이트 스크립팅 공격 단계</li>
                                    <ol>
                                        <li> 사용자는 정상적으로 애플리케이션에 로그인한 후 다음과 같이 세션 토큰을 포함하는 쿠니를 발행한다.</li>
                                        <li>공격자는 여러 방법을 통해 사용자가 내부에 자바스크립트를 포함하고 있는 URL을 클릭하도록 유도한다.</li>
                                        <li>사용자는 애플리케이션에 공격자에 의해 유도된 URL을 요청한다.</li>
                                        <li>서버는 사용자의 요청에 응답하고 그 결과 서버는 공격자가 생성한 크로스사이트 스크립팅 취약점을 포함한 자바스크립트를 사용자에게 보낸다.</li>
                                        <li>사용자는 공격자로부터 받은 자바스크립트를 실행한다.</li>
                                        <li>자바스크립트 코드가 실행되면서 사용자의 쿠키 정보를 공격자가 소유한 도메인으로 전송한다.</li>
                                        <li>공격자는 송하고 있는 도메인에서 사용자의 요청을 받아 가로챈 토큰을 사용해 사용자의 개인 정보에 대한 접근 권한을 얻는다.</li>
                                        <br>
                                    </ol>
                                    <li>쿠키는 오직 자신의 쿠키를 발행한 사이트에만 접근 가능하다. 쿠키는 쿠키를 발생한 사이트의 HTTP 요청에 의해서만 입력되며, 그 사이트의 반환된 페이지에 포함되거나 읽혀진 자바스크립트를 통해서만 접근될 수 있다. 즉 공격자가 소유한 도메인에서는 쿠키에 접근할 수 없지만 애플리케이션의 도메인에서는 쿠키에 접근할 수 있다는 것이다.</li>
                                    <li>피싱 공격은 공격 대상이 되는 애플리케이션의 복사본을 만드는 것이고 XSS는 실제 애플리케이션을 이용하는 것이다.</li>
                                </ul>
                            </div>
                        </ul>
                    </div>
                    <div>
                        <h3>1_2. 저장된 크로스사이트 스크립팅 취약점</h3>
                        <ul>
                            <li>저장된 크로스사이트 스크립팅 취약점은 사용자가 입력한 데이터가 애플리케이션 내에 저장되어서 필터링되거나 불안전한 문자를 안전한 상태로 만드는 불순물 제거 작업이 수행되지 않고 다른 사용자에게 보여지는 경우에 발생한다.</li>
                            <li>사용자가 애플리케이션 게시판에 자바스크립트가 포함된 질문을 등록할 수 있다면 애플리케이션은 그것을 필터링하지 못하고, 결국 공격자는 질문을 열람하는 사용자의 브라우저 내에서 악성 스크립트를 실행시킬 수 있다.</li>
                            <li>일반적으로 저장된 크로스사이트 스크립팅 취약점을 이용한 공격은 애플리케이션에 적어도 두 가지 요청을 한다.</li>
                            <ol>
                                <li>공격자는 악성코드가 담긴 조작된 데이터를 등록한다.</li>
                                <li>희생자는 공격자의 데이터에 담긴 악성코드가 실행되는 페이지를 열람한다.</li>
                                <br>
                            </ol>
                            <li>이런 취약점을 일컬어 세컨드 오더 크로스사이트 스크립팅이라고 한다.</li>
                            <li>공격에 크로스사이트되는 요소가 전혀 없기 때문에 이 문장에서 크로스사이트 스크립팅은 원래 잘못된 표현이댜.</li>
                            <li>저장된 크로스사이트 스크립팅 공격 단계</li>
                            <ol>
                                <li>공격자는 악성 자바스크립트가 담긴 질문을 게시물로 올린다.</li>
                                <li>사용자가 로그인 후 공격자의 질문을 열람한다.</li>
                                <li>서버는 사용자의 요청에 대한 응답으로 공격자의 자바스크립트를 실행한다.</li>
                                <li>사용자의 브라우저에서 공격자의 자바스크립트가 실행된다.</li>
                                <li>사용자의 브라우저는 공격자에게 세션 토큰을 보낸다.</li>
                                <li>공격자는 사용자의 세션을 이용하여 로그인한다.</li>
                                <br>
                            </ol>
                            <li>반사된 크로스사이트 스크립팅과 저장된 크로스사이트 스크립팅 공격에는 두 가지 중용한 차이점이 존재한다.</li>
                            <ol>
                                <li>반사도니 크로스사이트 스크립팅의 경우 공격자는 희생자를 조작된 URL로 방문하게 유도하기 위해 몇 가지 방법을 사용해야 한다. 그러나 저장된 크로스사이트 스크립팅의 경우에 공격자는 악용된 페이지나 함수를 검색하기 위해 희생자를 기다리기만 하면 된다.</li>
                                <li>반사된 XSS 공격에서 공격자는 사용자가 로그인해서 공격자가 제공한 링트를 클릭하게 유도함으로써 해당 사용자를 제어하거나, 사용자가 로그인 할 때까지 그 사용자를 기다리는 지속적인 페이로드를 애플리케이션 내에 배치할 수도 있다. 그러나 저장된 크로스사이트 스크립팅 공격에서 공격이 진핻되는 동일한 시간에 희생자들은 애플리케이션에 확실해 로그인한 생태여야 한다.</li>
                                <br>
                            </ol>
                            <div>
                                <h4>1_2_1. 업로드 된 파일에 크로스사이트 스크립팅 저장</h4>
                                <ul>
                                    <li>일반적인 저장된 XSS 취약점의 소스는 다른 사용자들에게 파일을 업로드할 수 있게 허용한 부분에서 공통적으로 찾아 볼 수 있다.</li>
                                    <li>자바스크립트를 포함하고 있는 HTML이나 텍스트를 이용해 공격을 할 수 있기 때문에 많은 애플리케이션은 이런 종류의 공격을 막기 위해 HTML파일을 업로드하는 것을 허용하지 않는다.</li>
                                    <li>그러나 대부분의 경우 JPEG 파일을 업로드하는 것은 허용하고 있어 XSS 페이로드를 포함하는 .jpg 확장자를 가진 파일을 이용하여 공격을 할 수 있다.</li>
                                </ul>
                            </div>
                        </ul>
                    </div>
                    <div>
                        <h3>1_3. DOM 기반의 크로스사이트 스크립팅 취약점</h3>
                        <ul>
                            <li>reflected XSS와 stored XSS는 세부적인 패턴을 가지고 있는데 이 특정 패턴은 애플리케이션이 사용자가 제어 가능한 데이터를 받아 이 데이터를 불안전한 방법으로 사용자에게 보여주는 부분에서 나타난다.</li>
                            <li>DOM 기반의 XSS 취약점은 이런 문자를 공유하고 있지 않고 공격자의 자바스크립트가 실행되는 과정은 다음과 같다.</li>
                            <ol>
                                <li>사용자는 공격자가 자바스크립트에 악의적인 코드를 삽입하여 만든 URL을 요청한다.</li>
                                <li>서버의 응답은 공격자의 스크립트를 포함하지 않는다.</li>
                                <li>사용자의 브라우저가 이런 응답을 처리할 떄 스크립트는 아무런 문제없이 실행된다.</li>
                                <br>
                            </ol>
                            <li>클라이언트 측 자바스크립트가 브라우저의 DOM에 접근할 수 있기 때문에 서버의 응답이 공격자의 스크립트를 포함하지 않을 수 있다.</li>
                            <li>DOM 기반의 XSS는 stored XSS보다 reflected XSS와 더 비슷하다.</li>
                            <li>일반적으로 DOM 기반의 XSS공격은 사용자에게 악성 코드가 포함되어있는 조작된 URL에 접근하게 유도해 악성 코드를 실행하게 한다. 그러나 응용된 기법을 살펴보면 reflected XSS과 DOM 기반 XSS 사이에는 중요한 차이점이 존재한다.</li>
                        </ul>
                    </div>
                    <div>
                        <h3>1_4. 실제적인 크로스사이트 스크립팅 공격</h3>
                        <ul>
                            <li>애플리케이션은 웹메일 애플리케이션의 브라우저가 사용자의 이메일을 열람하고 처리하는 과정에서 저장된 크로스사이트 스크립팅 공격에 취약할 수 있다.</li>
                            <li>이메일은 HTML 형태의 컨텐츠를 포함하기 떄문에 애플리케이션은 공격자의 악성 코드를 포함하는 HTML 페이지로 사용자를 이동시킬 수 있다.</li>
                        </ul>
                    </div>
                    <div>
                        <h3>1_5. 체이닝 크로스사이트 스크립팅과 다른 공격</h3>
                        <ul>
                            <li>XSS 취약점은 떄때로 파괴력 있는 악의적인 결과를 초래하기 위해 다른 취약점과 연계될 수 있다.</li>
                            <li>XSS의 위험도가 낮더라도 접근 제어 결감 취약점과 혼용하여 공격하면 공격자가 완벽하게 애플리케이션을 공격하는 것이 가능해진다.</li>
                        </ul>
                    </div>
                    <div>
                        <h3>1_6. 크로스사이트 스크립팅 공격 페이로드</h3>
                        <ul>
                            <li>지금까지 본 XSS 공격 페이로드는 다음과 같다.</li>
                            <ul>
                                <li>희생자의 세션 토큰 수집</li>
                                <li>세션 하이재킹</li>
                                <li>희생자의 권한으로 애플리케이션에 임의의 행동 수행</li>
                                <li>잠재적으로 다른 사용자의 권한 획득</li>
                                <br>
                            </ul>
                            <li>이 외에도 XSS 취약점을 통해 다양한 공격이 가능하다.</li>
                            <div>
                                <h4>1_6_1. 가상 웹페이지 변조</h4>
                                <ul>
                                    <li>애플리케이션의 사용자들을 현혹시키는 정보를 이용해 악의적인 데이터를 웹 애플리케이션의 페이지로 삽입할 수 있다.</li>
                                    <li>이 공격으로 공격자는 단순히 HTML을 사이트로 삽입할 수도 있으며 스크립트를 이용해 사이트에 정교한 컨텐츠를 삽입할 수도 있다.</li>
                                    <li>이때 대상 웹서버에 있는 실제 컨텐츠를 수정하는 것은 아니기 떄문에 이런 종류의 공격을 가상 웹페이지 변조라고 한다.</li>
                                    <li>애플리케이션이 사용자가 입력한 값을 처리하고 전송하는 과정에서 웹페이지 변조가 발생한다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>1_6_2. 트로이잔 삽입</h4>
                                <ul>
                                    <li>트로이잔 삽입 공격은 가상의 웹피이지 변조하에서 진행되면 공격자에게 정보를 전송하게 설계되어있는 취약한 애플리케이션에 민감한 정보를 전송하는 것과 같은 맥락으로, 취약한 애플리케이션을 사용하는 사용자들이 악의적인 행동을 하게 유도하는 함수를 삽입한다.</li>
                                    <li>이렇게 삽입된 함수는 공격자에 의해 제어된 서버로 기밀사항을 입력하느 트로이잔 로그인 폼을 사용자에게 보여준다.</li>
                                    <li>공격이 성공적으로 수행되면 공격자는 추적을 피하기 위해 희생자의 권한으로 실제 애플리케이션에 로그인한다.</li>
                                    <li>이런 공격에서 URL은 실제 애플리케이션의 정상적인 도메인을 ㄴ타내는데, 별도의 다른 도메인명으로 표시되는 순수한 피싱 웹사이트보다 유효한 SSL인증서를 이용해 민감한 정보를 입력하게 사용자들을 유도하는 것이 훨씬 수월하다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>1_6_3. 사용자 행동 유도</h4>
                                <ul>
                                    <li>공격자가 희생자의 세션을 가로챈다면 공격자는 희생자인 것처럼 애플리케이션을 이용할 수 있고 모든 행동을 수행할 수 있다.</li>
                                    <li>공격자는 공격받은 사용자로부터 획득한 세션 토큰의 결과물을 보기 위해 공격자의 서버를 모니터해야 한다. 그리고 모든 사용자를 대신해 관련된 핻동을 수행해야 한다.</li>
                                    <li>많은 사용자가 공격을 당하면 이 방법은 실용적이지 못할 것이다. 게다가 이 공격은 모든 애플리케이션 로그에 꽤 미모한 흔적을 남기는데, 그것은 조사가 진행되는 동안 비인가된 행동에 책임이 있는 컴퓨터를 확인하기 위해 사용될 수 있다.</li>
                                    <p class="stress"><b>이해가 잘 안됨 나중에 다시 읽어 볼것. 공격자가 다른 사용자의 행동을 유도해 목적을 이룬다는 말인가?</b></p>
                                </ul>
                            </div>
                            <div>
                                <h4>1_6_4. 신뢰 관계 악용</h4>
                                <ul>
                                    <li>브라우저는 웹사이트에서 발행된 쿠키와 함꼐 전송되는 자바스크립트를 신뢰한다.</li>
                                    <li>가끔씩 XSS 공격에 악용할 수 있는 몇가지의 다른 신뢰 관계가 존재한다.</li>
                                    <ul>
                                        <li>애플리케이션이 자동완성 기능이 있는 폼의 사용이 가능하다면 사용자 브라우저가 autocomplete 캐시에 저장한 모든 데이터를수집할 수 있다.</li>
                                    </ul>
                                    <li>autocomplete: 자동 완성, 사용자가 입력한 낱말의 나머지 부분을 응용 프로그램이 예측하는 기능이다.</li>
                                </ul>
                            </div>
                            <div>
                                <h4>1_6_5. 클라이언트 측 공격 증가</h4>
                                <ul>
                                    <li>웹사이트에 직접 방문하는 사용자를 공격하는 댜앙한 방법이 존재한다. 공격자는악의적인 웹사이트를 이용해 공격 스크립트를 직접 전달할 수 있지만 XSS 결함을 이용해 공격 스크립트를 취약한 애플리케이션으로 전송한다.</li>
                                    <li><b>키 입력 기록</b></li>
                                    <ul>
                                        <li>브라우저 윈도우가 활성화되는 동안 자바스크립트를 이용해 사용자 비밀번호와 사용자에 의해 눌려지는 개인적인 메시지나 개인 정보 등 모든 키 값을 모니터할 수 있다.</li>
                                        <li>개념 증명 스크립트(POC)</li>
                                        <p>document.onkeypress = function () { window.status += String.fromCharCode(window.event.keyCode);}</p>
                                        <br>
                                    </ul>
                                    <li><b>클립보드 컨텐츠 수집</b></li>
                                    <ul>
                                        <li>자바 스크립트를 이용해 클립보드의 컨탠츠를 수집할 수 있다.</li>
                                        <li>다음의 개념 증명 스크립트는 클립보드에 현재 컨텐츠를 포함하는 경고 창을 화면에 표시 할 것이다.</li>
                                        <p>alert(window.clipboardData.getData('Text'));</p>
                                        <br>
                                    </ul>
                                    <li><b>기록과 검색 쿼리 훔치기</b></li>
                                    <ul>
                                        <li>자바스크립트를 이용해 최근 사용자에 의해 방문된 웹사이트를 알아내고, 유명한 컴색엔진에서 수행된 쿼리를 밝혀내기 위한 무차별 대입 공격 테스트를 수행할 수 있다.</li>
                                        <li>사용자에게 최소한의 영향을 미치면서 가능한 많은 목표물의 리스트를 신속하게 체크할 수 있다.</li>
                                    </ul>
                                </ul>
                            </div>
                        </ul>
                    </div>
                </ul>
            </div>
            <div>
                <h2>2. 리다이텍션 공격</h2>
                <ul>
                    <li>리다이렉션 취약점은 애플리케이션이 사용자가 제어할 수 있는 입력을 받아 들여 리다이렉션 작업에 사용할 때 사용자 브라우저에 다른 URL을 방문하라고 명령을 내리면서 발생한다.</li>
                    <div>
                        <h3>2_1. 리다이렉션 취약점 발견과 악용</h3>
                        <ul>
                            <li>리다이렉션 취약점을 찾아내는 첫번째 방법은 애플리케이션 사용 중 리다이렉트가 발생하는 경우를 확인하는 것이다.</li>
                            <li>브라우저가 다른 URL로 리다이렉트하게 할 수 있는 방법</li>
                            <ol>
                                <li>HTTP 리다이렉트는 리다이렉트의 대상을 지정하는 3xx 상태 코드와 location 헤더 메시지를 사용한다.</li>
                                <li>일정 시간이 지난 후에 HTTP리프레시 헤더는 임의의 URL로 페이지를 다시 로드하는 데 사용할 수 있다. 여기서 임의의 URL로 리다이렉트되는 동안의 시간 간격을 인터벌이라 하는데, 임의의 URL로 즉시 리다이렉트 시키기 위해ㅑ 그 값이 0이 될수도 있다.</li>
                                <ul>
                                    <li>Refresh: 0; url=https://~~</li>
                                    <br>
                                </ul>
                                <li>HTTP 헤더에 표기할 수 있느 ㄴ내용을 HTML meta 태그를 통해 정의할 수 있으므로 이런 meta 태그를 이용해 리다이렉션이 가능하다.</li>
                                <ul>
                                    <li>meta http-equiv="refresh" content="0;url=https://~~"</li>
                                    <br>
                                </ul>
                                <li>임의의 URL로 브라우저를 리다이렉트하기 위해 자바스크립트의 다양한 API를 사용할 수 있다.</li>
                                <ul>
                                    <li>script document.location="https://~~"; script</li>
                                    <br>
                                </ul>
                                <br>
                            </ol>

                        </ul>
                    </div>
                </ul>
            </div>
        </ul>
        <br>
        <br>
        <br>
        <div>
            <h2>questions</h2>
            <ul>
                <li>세견  수정 결함</li>
                <li>버그 트랙</li>
                <li>피싱 공격</li>
                <li>웜</li>
                <li>하드 코딩</li>
                <li>반사된 크로스사이트 스크립팅: 사용자가 크로스사이트 스크립트 코드가 포함된 사바스크립트를 요청할 때 그 내용이 사용자에게 다시 되돌려지는 xss(퍼스트 오더 크로스사이트 스크립팅이라고도 함.)</li>
                <li>하이재킹: 사용자의 세션을 가로채 해당 사용자인 것처럼 위장하는 공격기법</li>
                <li>안티 멀웨어:</li>
                <li>세컨드 오더 크로스사이트 스크립팅: 공격자가 악성 코드가 담긴 조작된 데이터를 등록, 희생가가 공격자의 데이터에 담긴 악성코드가 실행되는 페이지를 열람하는 2단계에 걸쳐 일어나는 크로스사이트 스크립팅</li>
                <li>크로스 사이트 스크림팅: 사이트 간에 일어나는 스크립팅 즉 다른 도메인을 사용하는 사이트 간에 스크립트 코드를 실행하는 것인가?</li>
                <li>페이로드: 사용에 있어서 전송되는 데이터 </li>
                <li>1_2에서 반사된 XSS와 저장된 XSS의 차이점은 반사된 XSS는 url을 이용하는 것이고 저장된 XSS는 게시물을 이요하는 것인가?</li>
                <li>1_3에서 DOM기반 XSS는 다른 XSS와 같은 패턴을 공유하고 있지 않다고 했는데 자바스크립트가 실행되는 과정을 보면 사용자가 URL을 클릭하는 것이 데이터가 불안전한 방법으로 사용자에게 보여지는 것 아닌가? 아니면 서버의 응답으로 자바스크립트가 실행되지 않는다는 뜻인가?</li>
                <li>1_6_1 가상 웹페이지 변조가 이번에 신천지 홈페이지에 불상사진 올린 것과 같은 것인가?</li>
                <br>
                <br>
                <li>2. 만약 1 URL에서 2 URL로 리다이렉트 될 때 리다이렉트되는 대상이 1URL인가 2URL인가?</li>
                <li>상대주소는 슬래쉬를 이용하여 도메인의 하위 디렉토리를 적는 것인가?</li>
                <li>리다이렉션 공격은 사용자보다는 서버를 공격하는 거 아닌가? 리다이렉션 url을 서버에 저장하는 것이 아니잖아</li>
            </ul>
        </div>
    </body>
</html>
