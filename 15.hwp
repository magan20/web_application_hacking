15. 컴파일된 애플리케이션 공격
- 일반 운영체제의 실행 환경 위에서 실행되는 컴파일된 소프트웨어는 전통적으로 버퍼오버플로우나 포맷 스트링 버그와 같은 취약점이 많았다.
- 일반 언어를 사용하거나 이런 일반 언어를 부분적으로 사용하는 외부 컴포넌트를 이용하는 웹 애플리케이션도 있다.

버퍼 오버플로우 취약점
- 애플리케이션의 사용자가 제시한 데이터를 충분히 크지 않은 메모리 버퍼에 복사해서 담으려고 하는 경우에 발생한다.
- 그 결과 해당 버퍼가 오버플로우 되면서 사용자가 제공한 데이터 값으로 인근 메모리가 덮어써지게 된다.
- 취약점에 따라 공격자가 이 취약점을 이용해 임의의 코드를 실행하거나 다른 승인되지 않은 행동을 하게 악용할 수 있다.
- 스택 오버 플로우
    - 스택기반 오버플로우의 성공 여부는 일반적으로 스택에 저장된 함수의 반환 어드레스를 덮어쓰는 것에 달려있다.
    - 어떤 함수를 수행하면서 프러세서는 이 함수가 수행 완료된 후에 수행될 주소의 값을 스택에 저장한다.
    - 반환 어드레스 값의 바로 다음 스택부터 변수의 버퍼로 자리를 잡기 때문에 그 해당 변수에 오버플로우를 일으켜 반환 어드레스를 원하는 값으로 덮어쓸 수 있다.

- 힙 오버플로우
    - 힙 기반 오버플로우에서는 대상 버퍼에 인접해 있는 것은 반환 어드레스가 아니라 힙 제어 구조체로 구분돼있는 다른 힙 메모리 블록이다.
    - 힙은 이중 링크된 리스트로 되어있다. 
    - 각 블록은 앞에 제어 구조체를 달고 있는데, 제어 구조체에는 해당 블록의 크기, 힙 내의 선행 블록을 가리키는 포인터, 힙 내의 다음 블록을 가리키는 포인터 등이 덤겨 있다.
    - 힙 버퍼를 오버플로우 시키면 인근 힙 블록의 제어 구조체를 사용자가 제공한 데이터로 덮어쓸 수 있다.

- off-by-one 취약점
    - 이 취약점은 공격자가 할당된 버퍼의 끝을 넘어 한 바이트를 덮어쓸 수 있는 취약점까지 발생한다.

- 버퍼 오버플로우 취약점 탐색
    - 버퍼오버플로우 취약점을 탐지하기 위해서는 기본적으로 매우 긴 문자열 데이터를 전달해서 이상한 결과가 돌아오는지 본다.
    - 어떤 경우 미묘한 취약점이 존재해서 아주 특정 길이나 그 전후의 적은 범위 내에 있는 길이의 문자열만이 이상한 결과를 발생시킬 수 있다.
    - 프로그래머들은 고정 길이 버퍼를 주로 32, 100, 1024, 4096 과 같이 십진수나 십육진수의 끝자리로 할당하는 경우가 많다.
    - 해킹단계
        - 공격 대상 각 항목마다 일반적인 버퍼길이보다 길 수 있는 문자열을 낳어서 테스트 한다.
        - 한번에 한 항목씩 테스트 해서 해당 애플리케이션의 전체 코드 수행 경로를 테스트한다.
        - 애플리케이션의 반응을 살펴서 어떤 이상이라도 있는지 확인한다. 언쪠 이 에러가 발생하는지 원격에서 알기는 어려우나 다음과 같은 이벤트 형태로 나타날 수 있다.
            - 다른 변형된 입력에서는 발생하지 않았던 http 500상태코드나 에러 메시지가 긴 입력 값에서만 나타날 때
            - 내부의 일반 코드 컴포넌트에서 어떤 에러가 발생했다고 친절히 알려주는 메시지가 있을 때
            - 서버에서 완전하지 않거나 이상한 응답이 돌아올 때
            - 서버로의 TCP 커넥션이 응답을 받지 못하고 갑자기 끊어질 떄
            - 전체 웹 애플리케이션이 반응 없을 때
        - 힙 기반 오버플로우가 발생하면 시스템이 바로 멈추는 것이 아니라 조금 있다가 멈춘다는 것을 주목한다. 힙 커럽션을 발생시키는 몇 개의 테스트 케이스를 가지고 실험 해보는 것도 필요
        - off-by- one 취약점은 시스템 멈춤을 발생시키지는 않지만 애플리케이션이 오동작해 기대하지 않았던 ㄷ이터를 전송하는 결과를 낳는다.

정수 취약점
- 정수 오버플로우는 정수 삾에 대한 어떤 처리가 허용된 정수 값이 상한선을 넘어서면 거꾸로 최소 값보다 훨씬 적은 수를 의미하는 결과 값을 제시하게 되는 문제에서 발생한다.
- 부호 관련 문제   
    - 애플리케이션이 버퍼 길이를 측정하는 데 부호 있는 정수와 없는 정수를 혼용하다가 부호를 헷갈려서 부호 있는 값을 없는 값과 바로 비교하거나, 부호 없는 값을 받아야 하는 함수에 부호 있는 값을 넘겨주거나 할 떄 발생한다.
    - 두 가지 모두 부호 있는 값에서 부호가 무시돼 음수가 매우 큰 수로 돼버린다.

- 정수 취약점 탐지
    - 당연히 정수 취약점을 찾아볼 곳은 정수 값을 서버로 전달하는 부분들이다.
    - 이런 형태는 주로 두 가지 유형으로 발생한다.
        - 애플리케이션이 정수 값을 쿼리문, 쿠키나 메시지 본문 내에 매개변수로 전달할 수 있다. 이 숫자는 보통 10진수로 돼있고 표준 ASCII 문자를 사용할 것이다. 문자열과 같이 전달된는 문자열의 길ㅇ를 나타내는 필드가 가장 가능성이높은 대상이 될 것이다.
        - 애플리케이션은 정수 값을 대형 바이너리 객체 내에 담아서 전달할 수도 있다. 이 데이터는 액티브 x 컨트롤과 같은 클라이언트 측 컴포넌트에서 나온 것일 수도 있고, 숨겨진 폼 필드나 쿠키를 통해 전송되는 것일 수도 있다.

포맷 스트링 취약점
- 포맷 스트링 취약점은 c 언어에서의 printf류 함수에서처럼 오용될 소지가 있는 포맷 지시어를 받아들이는 함수에 사용자가 제어할 수 있는 입력 값을 포맷 스트링 인자로 전달하는 경우에 발생한다.
- 이 함수는 여러 개의 인자를 받아들이는데, 여기에는 숫자와 문자와 같은 여러 다양한 데이터 타입으로 구성될 수 있다.
- 함수로 전달되는 포맷 스트링은 이런 인자에 어떤 데이터가 담겨있으니 어떤 포맷으로 처리하라는 지시어를 담고 있다.
- 포맷 스트링 취약점 탐지
    - 여러 포맷 지시어를 담은 데이터를 대상 애플리케이션에 보내서 애플리케이션의 동작에 이상이 있는지를 감시하는 것이 가장 좋은 방법이다.
    - 버퍼 오버플로우 취약점과 마찬가지로 포맷 스트링 취약점에 대한 이런 탐지는 애플리케이션을 멈춰버리게 할 가능성이 높다.


new thing
- 포맷 스트링 공격: 포맷 스트링과 이것을 사용하는 printf()함수의 취약점을 이용하여 RET의 위치에 셸 코드의 주소를 읽어 셸을 획득하는 해킹 공격이다.
- 포맷 스트링: 일반적으로 사용자롭터 입력을 받아들이거나 결과를 출력하기 위해 사용하는 형식이다.(ex. 서식 지정자)
- RET: return의 약자로 리턴어드레스를 뜻한다.ret는 다음에 실행해야 하는 명령이 위치한 메모리 주소이다.
- sfp: 스택 주소값을 계산할 떄 현재 스택값의 바닥, 즉 기준을 잡을 때 필요한 프레임 포인터 값을 저장하는 곳이다.
- 버퍼: 컴퓨팅에서 버퍼는 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영영이다. 버퍼링이란 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 만한다. 다른 말로는 큐라고도 표현
- 반환 어드레스: 어떤 함수를 수행한 후 다음에 수행될 주소
- 스택 프레임: 함수 호출 시 할당되는 메모리 블록
- 프레임 포인터: 함수가 호출되기 전의 스택메모리 주소를 저장
- 널 종결자가 없으면 문자열을 읽을 때 그 끝을 지나서 우연히 널 바이트를 다음에 마주치게 될 때까지 인근 메모리를 계속 읽어 들인다.
- 엔디언: 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법응ㄹ 뜻한다. 바이트를 배열하는 방법을 특히 바이트 순서라 한다. 큰 단위가 앞에나오는 빅엔디언과 작은 단위가 앞에 나오는 리틀엔디언이 있다.
- 콜 스택: 컴퓨터 프로그램에서 현재 실행 중인 서브루틴에 관한 정보를 저장하는 스택 자료 구조이다.

questions
- c언어를 통해 프로그램을 작성할 때 모든 변수를 스택에 저장하나?
- 그럼 반환 어드레스는 스택에 첫번째로 저장되는 것인가?
